---
phase: 03-learning-materials
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260131000001_section_content.sql
  - src/types/materials.ts
  - src/lib/ai/materials/schemas.ts
autonomous: true

must_haves:
  truths:
    - "Tabela section_content istnieje w bazie danych"
    - "TypeScript types dla SectionContent i Source sa dostepne"
    - "Zod schemas dla walidacji contentu sa zdefiniowane"
  artifacts:
    - path: "supabase/migrations/20260131000001_section_content.sql"
      provides: "Section content table with RLS"
      contains: "CREATE TABLE section_content"
    - path: "src/types/materials.ts"
      provides: "TypeScript types for materials"
      exports: ["SectionContent", "Source", "Tool", "ExternalResource", "PracticalStep"]
    - path: "src/lib/ai/materials/schemas.ts"
      provides: "Zod validation schemas"
      exports: ["sectionContentSchema", "sourceSchema", "toolSchema"]
  key_links:
    - from: "src/types/materials.ts"
      to: "src/lib/ai/materials/schemas.ts"
      via: "z.infer<typeof schema>"
      pattern: "z\\.infer<typeof"
---

<objective>
Stworz fundament bazy danych i typow dla systemu materialow edukacyjnych.

Purpose: Przygotowanie infrastruktury storage i type safety dla generowanych materialow. Tabela section_content przechowuje markdown content z metadanymi o zrodlach. Typy TypeScript i Zod schemas zapewniaja spojnosc danych miedzy AI generation a storage.

Output: Migration SQL, TypeScript types, Zod validation schemas
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-learning-materials/03-RESEARCH.md
@src/types/database.ts
@supabase/migrations/20260130000001_courses_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration dla section_content</name>
  <files>supabase/migrations/20260131000001_section_content.sql</files>
  <action>
Stworz migration dla tabeli section_content:

```sql
-- Section content table - stores generated textbook-like materials
CREATE TABLE section_content (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chapter_id UUID NOT NULL REFERENCES chapters(id) ON DELETE CASCADE,

  -- Main content (markdown with inline citations)
  content TEXT NOT NULL,

  -- Structured data (JSONB for flexibility)
  key_concepts JSONB DEFAULT '[]',
  practical_steps JSONB DEFAULT '[]',
  tools JSONB DEFAULT '[]',
  external_resources JSONB DEFAULT '[]',

  -- Source tracking for anti-hallucination
  sources JSONB NOT NULL DEFAULT '[]',

  -- Metadata
  word_count INT,
  estimated_reading_minutes INT,
  language TEXT DEFAULT 'pl' CHECK (language IN ('pl', 'en')),

  -- Generation tracking
  generated_at TIMESTAMPTZ DEFAULT NOW(),
  generation_model TEXT,
  generation_cost_tokens INT,

  -- Versioning (for regeneration)
  version INT DEFAULT 1,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(chapter_id, version)
);

-- RLS policies (uzyj tego samego pattern co chapters - via course_id join)
ALTER TABLE section_content ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view content of own courses" ON section_content
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM chapters ch
      JOIN course_levels cl ON cl.id = ch.level_id
      JOIN courses c ON c.id = cl.course_id
      WHERE ch.id = section_content.chapter_id
      AND c.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert content to own courses" ON section_content
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM chapters ch
      JOIN course_levels cl ON cl.id = ch.level_id
      JOIN courses c ON c.id = cl.course_id
      WHERE ch.id = section_content.chapter_id
      AND c.user_id = auth.uid()
    )
  );

-- Indexes
CREATE INDEX idx_section_content_chapter ON section_content(chapter_id);
CREATE INDEX idx_section_content_sources ON section_content USING GIN (sources);

-- Trigger for updated_at (uzyj istniejaca funkcje update_updated_at_column)
CREATE TRIGGER update_section_content_updated_at
  BEFORE UPDATE ON section_content
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

WAZNE:
- RLS policy uzywa tego samego pattern via course_id join co chapters
- JSONB dla elastycznosci (key_concepts, practical_steps, tools, external_resources, sources)
- Versioning umozliwia regeneracje bez utraty starej wersji
- GIN index na sources dla szybkiego wyszukiwania
  </action>
  <verify>Plik migration istnieje i zawiera poprawna skladnie SQL. Weryfikuj recznie SQL syntax.</verify>
  <done>Migration gotowy do wykonania w Supabase SQL Editor</done>
</task>

<task type="auto">
  <name>Task 2: TypeScript types i Zod schemas</name>
  <files>src/types/materials.ts, src/lib/ai/materials/schemas.ts</files>
  <action>
1. Stworz `src/types/materials.ts`:

```typescript
/**
 * Types for Learning Materials (Section Content)
 *
 * Defines structures for AI-generated educational content with citations.
 */

export interface Source {
  id: string;
  title: string;
  url: string;
  type: 'documentation' | 'article' | 'video' | 'course' | 'official';
  accessedAt: string;
  snippet?: string;
}

export interface KeyConcept {
  term: string;
  definition: string;
  example?: string;
}

export interface PracticalStep {
  stepNumber: number;
  title: string;
  instruction: string;
  command?: string;
  expectedOutput?: string;
  explanation?: string;
}

export interface Tool {
  name: string;
  url: string;
  description: string;
  installCommand?: string;
  isFree: boolean;
}

export interface ExternalResource {
  title: string;
  url: string;
  type: 'docs' | 'tutorial' | 'video' | 'article' | 'course';
  language: 'pl' | 'en';
  description: string;
}

export interface SectionContent {
  id: string;
  chapterId: string;
  content: string;
  keyConcepts: KeyConcept[];
  practicalSteps: PracticalStep[];
  tools: Tool[];
  externalResources: ExternalResource[];
  sources: Source[];
  wordCount: number;
  estimatedReadingMinutes: number;
  language: 'pl' | 'en';
  generatedAt: string;
  generationModel?: string;
  generationCostTokens?: number;
  version: number;
}

// Database row type (snake_case)
export interface SectionContentRow {
  id: string;
  chapter_id: string;
  content: string;
  key_concepts: KeyConcept[];
  practical_steps: PracticalStep[];
  tools: Tool[];
  external_resources: ExternalResource[];
  sources: Source[];
  word_count: number | null;
  estimated_reading_minutes: number | null;
  language: string;
  generated_at: string;
  generation_model: string | null;
  generation_cost_tokens: number | null;
  version: number;
  created_at: string;
  updated_at: string;
}
```

2. Stworz `src/lib/ai/materials/schemas.ts`:

```typescript
import { z } from 'zod';

// Source schema for anti-hallucination tracking
export const sourceSchema = z.object({
  id: z.string(),
  title: z.string(),
  url: z.string().url(),
  type: z.enum(['documentation', 'article', 'video', 'course', 'official']),
  accessedAt: z.string().datetime(),
  snippet: z.string().optional(),
});

export const keyConceptSchema = z.object({
  term: z.string(),
  definition: z.string(),
  example: z.string().optional(),
});

export const practicalStepSchema = z.object({
  stepNumber: z.number().int().positive(),
  title: z.string(),
  instruction: z.string(),
  command: z.string().optional(),
  expectedOutput: z.string().optional(),
  explanation: z.string().optional(),
});

export const toolSchema = z.object({
  name: z.string(),
  url: z.string().url(),
  description: z.string(),
  installCommand: z.string().optional(),
  isFree: z.boolean(),
});

export const externalResourceSchema = z.object({
  title: z.string(),
  url: z.string().url(),
  type: z.enum(['docs', 'tutorial', 'video', 'article', 'course']),
  language: z.enum(['pl', 'en']),
  description: z.string(),
});

// Full section content schema for AI generation
export const sectionContentSchema = z.object({
  content: z.string().describe('Tresc w formacie markdown z inline citations [1], [2]'),
  keyConcepts: z.array(keyConceptSchema).default([]),
  practicalSteps: z.array(practicalStepSchema).default([]),
  tools: z.array(toolSchema).default([]),
  externalResources: z.array(externalResourceSchema).default([]),
  sources: z.array(sourceSchema),
  wordCount: z.number().int().positive(),
  estimatedReadingMinutes: z.number().int().positive(),
});

export type SectionContentGenerated = z.infer<typeof sectionContentSchema>;
export type Source = z.infer<typeof sourceSchema>;
export type KeyConcept = z.infer<typeof keyConceptSchema>;
export type PracticalStep = z.infer<typeof practicalStepSchema>;
export type Tool = z.infer<typeof toolSchema>;
export type ExternalResource = z.infer<typeof externalResourceSchema>;
```

WAZNE:
- Typy maja camelCase (frontend), database row ma snake_case
- Zod schemas maja .describe() dla AI generation guidance
- sourceSchema wymaga url().datetime() dla walidacji
- Schema i types sa zsynchronizowane
  </action>
  <verify>
    - `npx tsc --noEmit` - brak bledow TypeScript
    - Importy dzialaja: `import { SectionContent } from '@/types/materials'`
  </verify>
  <done>TypeScript types i Zod schemas gotowe do uzycia przez API i UI</done>
</task>

</tasks>

<verification>
1. Migration file istnieje w supabase/migrations/
2. `npx tsc --noEmit` przechodzi bez bledow
3. Typy mozna importowac z @/types/materials
4. Schemas mozna importowac z @/lib/ai/materials/schemas
</verification>

<success_criteria>
- [ ] Migration SQL poprawny skladniowo
- [ ] Typy SectionContent, Source, Tool, PracticalStep exported
- [ ] Zod schemas dla AI generation zdefiniowane
- [ ] Brak bledow TypeScript w projekcie
</success_criteria>

<output>
After completion, create `.planning/phases/03-learning-materials/03-01-SUMMARY.md`
</output>
