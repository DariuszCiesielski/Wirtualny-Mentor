---
phase: 03-learning-materials
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/lib/dal/materials.ts
  - src/app/api/materials/generate/route.ts
autonomous: true

must_haves:
  truths:
    - "API endpoint generuje materialy dla chapter"
    - "DAL zapisuje i pobiera content z bazy danych"
    - "Lazy generation - content tworzony tylko gdy potrzebny"
    - "Wygenerowane materialy zawieraja sekcje z interpretacja wynikow"
  artifacts:
    - path: "src/lib/dal/materials.ts"
      provides: "Data access layer for section content"
      exports: ["getSectionContent", "saveSectionContent", "getOrGenerateContent"]
    - path: "src/app/api/materials/generate/route.ts"
      provides: "API endpoint for content generation"
      exports: ["POST"]
  key_links:
    - from: "src/lib/dal/materials.ts"
      to: "@/lib/supabase/server"
      via: "createClient import"
      pattern: "import.*createClient.*from.*supabase/server"
    - from: "src/app/api/materials/generate/route.ts"
      to: "@/lib/ai/materials/tools"
      via: "materialGenerationTools import"
      pattern: "import.*materialGenerationTools"
    - from: "src/app/api/materials/generate/route.ts"
      to: "@/lib/ai/providers"
      via: "getModel import"
      pattern: "import.*getModel.*from.*ai/providers"
---

<objective>
Stworz DAL i API endpoint dla generowania materialow edukacyjnych.

Purpose: API endpoint uzywa multi-step tool calling (research phase -> generation phase) do tworzenia grounded content. DAL zapewnia lazy generation - content tworzony tylko gdy uzytkownik otwiera chapter, nie przy generacji curriculum.

Output: DAL functions dla materials, API POST /api/materials/generate
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-learning-materials/03-RESEARCH.md
@src/lib/ai/materials/schemas.ts
@src/lib/ai/materials/prompts.ts
@src/lib/ai/materials/tools.ts
@src/lib/ai/providers.ts
@src/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DAL dla section content</name>
  <files>src/lib/dal/materials.ts</files>
  <action>
Stworz `src/lib/dal/materials.ts`:

```typescript
/**
 * Data Access Layer - Materials (Section Content)
 *
 * CRUD operations for AI-generated learning materials.
 * Implements lazy generation pattern - content created on first access.
 */

import { createClient } from '@/lib/supabase/server';
import type { SectionContent, SectionContentRow } from '@/types/materials';

/**
 * Transform database row to frontend type (snake_case -> camelCase)
 */
function transformRow(row: SectionContentRow): SectionContent {
  return {
    id: row.id,
    chapterId: row.chapter_id,
    content: row.content,
    keyConcepts: row.key_concepts || [],
    practicalSteps: row.practical_steps || [],
    tools: row.tools || [],
    externalResources: row.external_resources || [],
    sources: row.sources || [],
    wordCount: row.word_count || 0,
    estimatedReadingMinutes: row.estimated_reading_minutes || 0,
    language: row.language as 'pl' | 'en',
    generatedAt: row.generated_at,
    generationModel: row.generation_model || undefined,
    generationCostTokens: row.generation_cost_tokens || undefined,
    version: row.version,
  };
}

/**
 * Get existing section content for a chapter
 *
 * @param chapterId - The chapter ID
 * @returns Latest version of section content or null if not generated
 */
export async function getSectionContent(
  chapterId: string
): Promise<SectionContent | null> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('section_content')
    .select('*')
    .eq('chapter_id', chapterId)
    .order('version', { ascending: false })
    .limit(1)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return null; // Not found
    }
    throw new Error(`Failed to get section content: ${error.message}`);
  }

  return transformRow(data as SectionContentRow);
}

/**
 * Save generated section content
 *
 * @param chapterId - The chapter ID
 * @param content - Generated content to save
 * @param generationModel - Model used for generation
 * @param costTokens - Token cost of generation
 * @returns Saved section content
 */
export async function saveSectionContent(
  chapterId: string,
  content: Omit<SectionContent, 'id' | 'chapterId' | 'version' | 'generatedAt'>,
  generationModel?: string,
  costTokens?: number
): Promise<SectionContent> {
  const supabase = await createClient();

  // Get current max version for this chapter
  const { data: existing } = await supabase
    .from('section_content')
    .select('version')
    .eq('chapter_id', chapterId)
    .order('version', { ascending: false })
    .limit(1)
    .single();

  const nextVersion = existing ? existing.version + 1 : 1;

  const { data, error } = await supabase
    .from('section_content')
    .insert({
      chapter_id: chapterId,
      content: content.content,
      key_concepts: content.keyConcepts,
      practical_steps: content.practicalSteps,
      tools: content.tools,
      external_resources: content.externalResources,
      sources: content.sources,
      word_count: content.wordCount,
      estimated_reading_minutes: content.estimatedReadingMinutes,
      language: content.language || 'pl',
      generation_model: generationModel,
      generation_cost_tokens: costTokens,
      version: nextVersion,
    })
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to save section content: ${error.message}`);
  }

  return transformRow(data as SectionContentRow);
}

/**
 * Check if content exists for a chapter (without fetching full content)
 *
 * @param chapterId - The chapter ID
 * @returns True if content exists
 */
export async function hasContent(chapterId: string): Promise<boolean> {
  const supabase = await createClient();

  const { count, error } = await supabase
    .from('section_content')
    .select('id', { count: 'exact', head: true })
    .eq('chapter_id', chapterId);

  if (error) {
    throw new Error(`Failed to check content: ${error.message}`);
  }

  return (count ?? 0) > 0;
}

/**
 * Get all content versions for a chapter
 *
 * @param chapterId - The chapter ID
 * @returns Array of all versions (metadata only)
 */
export async function getContentVersions(
  chapterId: string
): Promise<Array<{ version: number; generatedAt: string; wordCount: number }>> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('section_content')
    .select('version, generated_at, word_count')
    .eq('chapter_id', chapterId)
    .order('version', { ascending: false });

  if (error) {
    throw new Error(`Failed to get versions: ${error.message}`);
  }

  return (data || []).map((row) => ({
    version: row.version,
    generatedAt: row.generated_at,
    wordCount: row.word_count || 0,
  }));
}
```

WAZNE:
- Uzywa tego samego pattern co courses.ts (createClient, error handling)
- transformRow konwertuje snake_case (DB) -> camelCase (frontend)
- Version tracking dla regeneracji (nie nadpisuje, dodaje nowa wersje)
- hasContent dla szybkiego sprawdzenia bez pobierania danych
  </action>
  <verify>
    - `npx tsc --noEmit` - brak bledow TypeScript
    - Eksportuje: getSectionContent, saveSectionContent, hasContent, getContentVersions
  </verify>
  <done>DAL dla section content gotowy</done>
</task>

<task type="auto">
  <name>Task 2: API endpoint dla material generation</name>
  <files>src/app/api/materials/generate/route.ts</files>
  <action>
Stworz `src/app/api/materials/generate/route.ts`:

UWAGA: Ten endpoint jest zlozony (~200 linii) ale logicznie spojny. Zawiera:
- Research phase (tool calling dla zbierania zrodel)
- Generation phase (structured output z zebranych zrodel)
- Save phase (zapis do DB)

Jesli napotykasz problemy podczas implementacji, skup sie na jednej fazie na raz.

```typescript
/**
 * API Route: Generate Learning Materials
 *
 * POST /api/materials/generate
 *
 * Two-phase generation:
 * 1. Research phase - AI gathers information with web search tools
 * 2. Generation phase - AI creates structured content from gathered sources
 *
 * Typical execution time: 30-90 seconds (depends on web search latency)
 */

import { NextRequest, NextResponse } from 'next/server';
import { streamText, generateObject } from 'ai';
import { z } from 'zod';
import { getModel } from '@/lib/ai/providers';
import { sectionContentSchema } from '@/lib/ai/materials/schemas';
import { materialGenerationTools, type CollectedSource } from '@/lib/ai/materials/tools';
import {
  RESEARCH_SYSTEM_PROMPT,
  MATERIAL_GENERATION_PROMPT,
  CONTENT_GENERATION_USER_PROMPT,
} from '@/lib/ai/materials/prompts';
import { saveSectionContent } from '@/lib/dal/materials';
import { createClient } from '@/lib/supabase/server';

// Request validation schema
const requestSchema = z.object({
  chapterId: z.string().uuid(),
  chapterTitle: z.string(),
  chapterDescription: z.string(),
  topics: z.array(z.string()),
  courseContext: z.string().optional(),
});

/**
 * Phase 1: Research - gather sources using AI tool calling
 */
async function runResearchPhase(
  chapterTitle: string,
  chapterDescription: string,
  topics: string[],
  courseContext?: string
): Promise<CollectedSource[]> {
  console.log('[Materials] Starting research phase for:', chapterTitle);

  const collectedSources: CollectedSource[] = [];

  const researchResult = await streamText({
    model: getModel('curriculum'),
    system: RESEARCH_SYSTEM_PROMPT,
    prompt: `Zbierz informacje do rozdzialu: "${chapterTitle}"
Opis: ${chapterDescription}
Tematy do pokrycia: ${topics.join(', ')}
${courseContext ? `Kontekst kursu: ${courseContext}` : ''}

Wyszukaj:
1. Oficjalna dokumentacje
2. Praktyczne tutoriale
3. Narzedzia i ich linki instalacyjne
4. Przyklady kodu/komend

Uzyj narzedzia searchResources dla kazdego tematu.`,
    tools: materialGenerationTools,
    maxSteps: 5,
  });

  // Collect tool results
  for await (const event of researchResult.fullStream) {
    if (event.type === 'tool-result') {
      const result = event.result as { success?: boolean; sources?: CollectedSource[] };
      if (result.success && result.sources) {
        collectedSources.push(...result.sources);
      }
    }
  }

  console.log('[Materials] Research complete, found', collectedSources.length, 'sources');
  return collectedSources;
}

/**
 * Deduplicate and limit sources
 */
function processCollectedSources(sources: CollectedSource[], limit: number = 10): CollectedSource[] {
  // Deduplicate by URL
  const uniqueSources = sources.reduce<CollectedSource[]>((acc, source) => {
    const normalizedUrl = source.url.replace(/\/$/, '').toLowerCase();
    if (!acc.some(s => s.url.replace(/\/$/, '').toLowerCase() === normalizedUrl)) {
      acc.push(source);
    }
    return acc;
  }, []);

  // Limit to prevent context overflow
  return uniqueSources.slice(0, limit);
}

export async function POST(request: NextRequest) {
  try {
    // Validate request
    const body = await request.json();
    const parsed = requestSchema.safeParse(body);

    if (!parsed.success) {
      return NextResponse.json(
        { error: 'Invalid request', details: parsed.error.flatten() },
        { status: 400 }
      );
    }

    const { chapterId, chapterTitle, chapterDescription, topics, courseContext } = parsed.data;

    // Verify user has access to this chapter
    const supabase = await createClient();
    const { data: chapter, error: chapterError } = await supabase
      .from('chapters')
      .select(`
        id,
        level:course_levels!inner (
          course:courses!inner (
            user_id
          )
        )
      `)
      .eq('id', chapterId)
      .single();

    if (chapterError || !chapter) {
      return NextResponse.json(
        { error: 'Chapter not found or access denied' },
        { status: 404 }
      );
    }

    // Get user from auth
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Phase 1: Research
    const collectedSources = await runResearchPhase(
      chapterTitle,
      chapterDescription,
      topics,
      courseContext
    );

    const limitedSources = processCollectedSources(collectedSources);

    // Phase 2: Generate structured content
    console.log('[Materials] Starting generation phase with', limitedSources.length, 'sources');

    const contentResult = await generateObject({
      model: getModel('curriculum'),
      schema: sectionContentSchema,
      system: MATERIAL_GENERATION_PROMPT,
      prompt: CONTENT_GENERATION_USER_PROMPT(
        chapterTitle,
        chapterDescription,
        topics,
        limitedSources.map(s => ({
          title: s.title,
          url: s.url,
          content: s.content,
        }))
      ),
    });

    // Prepare sources for storage (transform to Source format)
    const sourcesForStorage = limitedSources.map((s, i) => ({
      id: s.id || `src-${i + 1}`,
      title: s.title,
      url: s.url,
      type: (s.type as 'documentation' | 'article' | 'video' | 'course' | 'official') || 'article',
      accessedAt: new Date().toISOString(),
      snippet: s.content.slice(0, 500),
    }));

    // Phase 3: Save to database
    const savedContent = await saveSectionContent(
      chapterId,
      {
        content: contentResult.object.content,
        keyConcepts: contentResult.object.keyConcepts,
        practicalSteps: contentResult.object.practicalSteps,
        tools: contentResult.object.tools,
        externalResources: contentResult.object.externalResources,
        sources: sourcesForStorage,
        wordCount: contentResult.object.wordCount,
        estimatedReadingMinutes: contentResult.object.estimatedReadingMinutes,
        language: 'pl',
      },
      'gpt-4.1', // TODO: Track actual model from getModel
      contentResult.usage?.totalTokens
    );

    console.log('[Materials] Content saved, version:', savedContent.version);

    return NextResponse.json({
      success: true,
      content: savedContent,
    });

  } catch (error) {
    console.error('[Materials] Generation error:', error);
    return NextResponse.json(
      { error: 'Failed to generate content', message: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
```

WAZNE:
- Wydzielono runResearchPhase i processCollectedSources jako osobne funkcje dla czytelnosci
- Two-phase: research (tool calling) -> generation (structured output)
- Weryfikacja dostepu usera do chapter przed generacja
- Deduplikacja zrodel po URL
- Limit 10 zrodel dla context window
- Zapisuje do DB przez DAL
- Logowanie dla debugowania
- Error handling z descriptive messages
  </action>
  <verify>
    - `npx tsc --noEmit` - brak bledow TypeScript
    - POST handler eksportowany
    - Importy z @/lib/ai/materials/* dzialaja
  </verify>
  <done>API endpoint dla material generation gotowy</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` przechodzi bez bledow
2. DAL functions dostepne w src/lib/dal/materials.ts
3. API endpoint dostepny pod /api/materials/generate
4. API uzywa tool calling do research phase
</verification>

<success_criteria>
- [ ] getSectionContent pobiera content z bazy
- [ ] saveSectionContent zapisuje z version tracking
- [ ] POST /api/materials/generate wykonuje two-phase generation
- [ ] Zrodla sa deduplikowane i limitowane
- [ ] Generated content zawiera sekcje "Jak interpretowac wyniki" lub "Oczekiwany wynik" (weryfikacja MAT-06)
- [ ] Brak bledow TypeScript
</success_criteria>

<output>
After completion, create `.planning/phases/03-learning-materials/03-03-SUMMARY.md`
</output>
