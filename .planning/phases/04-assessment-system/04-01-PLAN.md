---
phase: 04-assessment-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260131100001_quizzes_schema.sql
  - src/types/quiz.ts
  - src/lib/ai/quiz/schemas.ts
autonomous: true

must_haves:
  truths:
    - "Tabela quizzes istnieje w bazie danych z JSONB questions"
    - "Tabela quiz_attempts istnieje z tracking wynikow"
    - "Tabela level_unlocks istnieje dla odblokowywania poziomow"
    - "RLS policies izoluja dane uzytkownikow"
    - "TypeScript types dla quiz entities sa dostepne"
  artifacts:
    - path: "supabase/migrations/20260131100001_quizzes_schema.sql"
      provides: "Quiz tables, RLS, indexes"
      contains: "CREATE TABLE quizzes"
    - path: "src/types/quiz.ts"
      provides: "Quiz type definitions"
      exports: ["Quiz", "QuizAttempt", "QuizQuestion", "LevelUnlock"]
    - path: "src/lib/ai/quiz/schemas.ts"
      provides: "Zod schemas dla AI quiz generation"
      exports: ["quizSchema", "levelTestSchema", "questionSchema"]
  key_links:
    - from: "src/types/quiz.ts"
      to: "src/lib/ai/quiz/schemas.ts"
      via: "Zod inference"
      pattern: "z\\.infer"
---

<objective>
Stworzyc fundament bazodanowy i typowanie dla systemu quizow.

Purpose: Baza danych i typy sa wymagane przed implementacja logiki generowania i UI.
Output: Migration SQL, TypeScript types, Zod schemas dla AI generation.
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-assessment-system/04-RESEARCH.md
@src/types/database.ts
@src/types/materials.ts
@src/lib/ai/materials/schemas.ts
@supabase/migrations/20260130000001_courses_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration dla quiz schema</name>
  <files>supabase/migrations/20260131100001_quizzes_schema.sql</files>
  <action>
Utworz migration file z trzema tabelami zgodnie z research:

**Tabela quizzes:**
- id UUID PRIMARY KEY
- chapter_id UUID REFERENCES chapters(id) ON DELETE CASCADE (nullable)
- level_id UUID REFERENCES course_levels(id) ON DELETE CASCADE (nullable)
- quiz_type TEXT CHECK ('section', 'level_test')
- questions JSONB NOT NULL DEFAULT '[]'
- question_count INT NOT NULL
- estimated_minutes INT
- pass_threshold NUMERIC(3,2) DEFAULT 0.70
- generated_at TIMESTAMPTZ DEFAULT NOW()
- generation_model TEXT
- version INT DEFAULT 1
- created_at TIMESTAMPTZ DEFAULT NOW()
- UNIQUE(chapter_id, version) dla section quizzes
- UNIQUE(level_id, quiz_type, version) dla level tests
- CHECK constraint: exactly one of chapter_id or level_id must be NOT NULL

**Tabela quiz_attempts:**
- id UUID PRIMARY KEY
- user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- quiz_id UUID NOT NULL REFERENCES quizzes(id) ON DELETE CASCADE
- answers JSONB NOT NULL DEFAULT '{}'
- score NUMERIC(5,2)
- correct_count INT
- total_count INT
- passed BOOLEAN
- started_at TIMESTAMPTZ DEFAULT NOW()
- submitted_at TIMESTAMPTZ
- time_spent_seconds INT
- remediation_viewed BOOLEAN DEFAULT FALSE
- remediation_content JSONB
- created_at TIMESTAMPTZ DEFAULT NOW()

**Tabela level_unlocks:**
- id UUID PRIMARY KEY
- user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- level_id UUID NOT NULL REFERENCES course_levels(id) ON DELETE CASCADE
- unlock_type TEXT NOT NULL CHECK ('test_passed', 'manual_skip')
- unlocked_at TIMESTAMPTZ DEFAULT NOW()
- passing_attempt_id UUID REFERENCES quiz_attempts(id) (nullable)
- UNIQUE(user_id, level_id)

**RLS Policies:**
- quizzes: SELECT via course ownership (join przez chapters/course_levels -> courses)
- quiz_attempts: ALL dla wlasnych recordow (user_id = auth.uid())
- level_unlocks: ALL dla wlasnych recordow (user_id = auth.uid())

**Indexes:**
- idx_quizzes_chapter ON quizzes(chapter_id)
- idx_quizzes_level ON quizzes(level_id)
- idx_attempts_user_quiz ON quiz_attempts(user_id, quiz_id)
- idx_unlocks_user_level ON level_unlocks(user_id, level_id)

Uzyj wzorca RLS z courses_schema.sql (EXISTS join pattern).
  </action>
  <verify>
Sprawdz SQL syntax:
- Plik istnieje w supabase/migrations/
- Nie ma syntax errors (sprawdz przez manual review)
- CHECK constraints poprawne
- RLS policies uzywaja auth.uid()
  </verify>
  <done>
- Migration file gotowy do uruchomienia w Supabase SQL Editor
- 3 tabele z RLS policies
- Proper indexes dla wydajnosci
  </done>
</task>

<task type="auto">
  <name>Task 2: TypeScript types i Zod schemas</name>
  <files>src/types/quiz.ts, src/lib/ai/quiz/schemas.ts</files>
  <action>
**src/types/quiz.ts:**
Utworz typy zgodnie z database schema:

```typescript
// Quiz types
export type QuizType = 'section' | 'level_test';
export type UnlockType = 'test_passed' | 'manual_skip';
export type QuestionType = 'multiple_choice' | 'true_false';
export type BloomLevel = 'remembering' | 'understanding' | 'applying' | 'analyzing';
export type Difficulty = 'easy' | 'medium' | 'hard';

// Question option
export interface QuestionOption {
  id: string;  // 'a', 'b', 'c', 'd'
  text: string;
}

// Quiz question (stored in JSONB)
export interface QuizQuestion {
  id: string;
  type: QuestionType;
  question: string;  // or 'statement' for true_false
  options: QuestionOption[];
  correctOptionId: string;
  explanation: string;
  wrongExplanations: Record<string, string>;
  bloomLevel: BloomLevel;
  difficulty: Difficulty;
  relatedConcept?: string;
}

// Database row types (snake_case)
export interface QuizRow { ... }
export interface QuizAttemptRow { ... }
export interface LevelUnlockRow { ... }

// Application types (camelCase)
export interface Quiz { ... }
export interface QuizAttempt { ... }
export interface LevelUnlock { ... }

// Input types
export interface CreateQuizInput { ... }
export interface SubmitQuizInput { answers: Record<string, string> }

// Result types
export interface QuizResults {
  score: number;
  correctCount: number;
  totalCount: number;
  passed: boolean;
  questionResults: QuestionResult[];
}

export interface QuestionResult {
  questionId: string;
  selectedOptionId: string;
  correctOptionId: string;
  isCorrect: boolean;
  explanation: string;
}
```

**src/lib/ai/quiz/schemas.ts:**
Utworz Zod schemas dla AI generation (wzorzec z materials/schemas.ts):

```typescript
import { z } from 'zod';

// Option schema
const optionSchema = z.object({
  id: z.string().describe("Option ID: a, b, c, d"),
  text: z.string().describe("Option text in Polish"),
});

// Multiple choice question
const multipleChoiceSchema = z.object({
  id: z.string().describe("Unique ID like 'q-1'"),
  type: z.literal('multiple_choice'),
  question: z.string().describe("Question text in Polish"),
  options: z.array(optionSchema).length(4),
  correctOptionId: z.string(),
  explanation: z.string().describe("Why correct answer is correct"),
  wrongExplanations: z.record(z.string(), z.string())
    .describe("optionId -> explanation why wrong"),
  bloomLevel: z.enum(['remembering', 'understanding', 'applying', 'analyzing']),
  difficulty: z.enum(['easy', 'medium', 'hard']),
  relatedConcept: z.string().optional(),
});

// True/False question
const trueFalseSchema = z.object({
  id: z.string(),
  type: z.literal('true_false'),
  question: z.string().describe("Statement to evaluate"),
  options: z.array(optionSchema).length(2), // Prawda, Falsz
  correctOptionId: z.string(), // 'a' or 'b'
  explanation: z.string(),
  wrongExplanations: z.record(z.string(), z.string()),
  bloomLevel: z.enum(['remembering', 'understanding']),
  difficulty: z.enum(['easy', 'medium']),
  relatedConcept: z.string().optional(),
});

// Union
export const questionSchema = z.discriminatedUnion('type', [
  multipleChoiceSchema,
  trueFalseSchema,
]);

// Section quiz (5 questions)
export const quizSchema = z.object({
  questions: z.array(questionSchema).min(3).max(10),
  estimatedMinutes: z.number().int().positive(),
  focusAreas: z.array(z.string()),
});

// Level test (15 questions)
export const levelTestSchema = z.object({
  questions: z.array(questionSchema).min(10).max(20),
  estimatedMinutes: z.number().int().positive(),
  levelSummary: z.string(),
  masteryIndicators: z.array(z.string()),
});

// Remediation content
export const remediationSchema = z.object({
  weakConcepts: z.array(z.object({
    concept: z.string(),
    explanation: z.string(),
    example: z.string(),
  })),
  practiceHints: z.array(z.string()),
  suggestedReview: z.array(z.string()),
});

// Inferred types
export type QuizQuestionSchema = z.infer<typeof questionSchema>;
export type QuizSchema = z.infer<typeof quizSchema>;
export type LevelTestSchema = z.infer<typeof levelTestSchema>;
export type RemediationSchema = z.infer<typeof remediationSchema>;
```

Wszystkie schemas maja `.describe()` dla AI generation guidance.
  </action>
  <verify>
Sprawdz TypeScript compilation:
```bash
npx tsc --noEmit
```
Importy dzialaja:
```typescript
import type { Quiz, QuizQuestion } from '@/types/quiz';
import { quizSchema } from '@/lib/ai/quiz/schemas';
```
  </verify>
  <done>
- Types exportowane z @/types/quiz
- Schemas exportowane z @/lib/ai/quiz/schemas
- TypeScript kompiluje bez bledow
- Schemas maja .describe() dla AI
  </done>
</task>

</tasks>

<verification>
1. Migration file istnieje: `ls supabase/migrations/20260131100001_quizzes_schema.sql`
2. Types file istnieje: `ls src/types/quiz.ts`
3. Schemas file istnieje: `ls src/lib/ai/quiz/schemas.ts`
4. TypeScript kompiluje: `npx tsc --noEmit` passes
5. SQL nie ma syntax errors (manual review)
</verification>

<success_criteria>
- 3 tabele zdefiniowane w migration (quizzes, quiz_attempts, level_unlocks)
- RLS policies dla wszystkich tabel
- TypeScript types matching database schema
- Zod schemas z .describe() dla AI generation
- Projekt kompiluje bez bledow
</success_criteria>

<output>
After completion, create `.planning/phases/04-assessment-system/04-01-SUMMARY.md`
</output>
