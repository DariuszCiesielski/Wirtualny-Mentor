---
phase: 04-assessment-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ai/quiz/prompts.ts
  - src/lib/dal/quizzes.ts
  - src/app/api/quiz/generate/route.ts
  - src/app/api/quiz/submit/route.ts
autonomous: true

must_haves:
  truths:
    - "AI moze generowac quizy z uzyciem generateObject"
    - "Quiz moze byc zapisany i pobrany z bazy danych"
    - "Odpowiedzi moga byc ewaluowane server-side"
    - "Score jest obliczany poprawnie"
  artifacts:
    - path: "src/lib/ai/quiz/prompts.ts"
      provides: "System prompts dla quiz generation"
      exports: ["QUIZ_GENERATION_PROMPT", "LEVEL_TEST_PROMPT", "REMEDIATION_PROMPT"]
    - path: "src/lib/dal/quizzes.ts"
      provides: "Quiz CRUD operations"
      exports: ["saveQuiz", "getQuiz", "getQuizByChapter", "createAttempt", "submitAttempt"]
    - path: "src/app/api/quiz/generate/route.ts"
      provides: "Quiz generation endpoint"
      exports: ["POST"]
    - path: "src/app/api/quiz/submit/route.ts"
      provides: "Quiz submission endpoint"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/quiz/generate/route.ts"
      to: "src/lib/dal/quizzes.ts"
      via: "saveQuiz, getQuizByChapter"
      pattern: "import.*from.*dal/quizzes"
    - from: "src/app/api/quiz/submit/route.ts"
      to: "src/lib/dal/quizzes.ts"
      via: "createAttempt, submitAttempt"
      pattern: "submitAttempt"
---

<objective>
Zbudowac backend dla generowania quizow przez AI i ewaluacji odpowiedzi.

Purpose: Backend jest wymagany przed UI - pozwala na generowanie i scoring quizow.
Output: AI prompts, DAL functions, API endpoints dla generate i submit.
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-assessment-system/04-RESEARCH.md
@src/lib/ai/providers.ts
@src/lib/ai/materials/prompts.ts
@src/lib/dal/materials.ts
@src/app/api/materials/generate/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: AI prompts dla quiz generation</name>
  <files>src/lib/ai/quiz/prompts.ts</files>
  <action>
Utworz system prompts dla AI quiz generation (wzorzec z materials/prompts.ts):

```typescript
/**
 * AI Prompts for Quiz Generation
 * Used with generateObject for structured quiz output
 */

export const QUIZ_GENERATION_PROMPT = `Jestes ekspertem w tworzeniu quizow edukacyjnych.

ZADANIE: Wygeneruj quiz sprawdzajacy zrozumienie materialu.

ZASADY:
1. Pytania musza byc w jezyku polskim
2. Kazde pytanie ma JEDNA poprawna odpowiedz
3. Opcje odpowiedzi sa precyzyjne i jednoznaczne
4. Bledne odpowiedzi sa wiarygodne (nie oczywiscie falszywe)
5. Wyjasnienia sa edukacyjne - pomagaja zrozumiec dlaczego

STRUKTURA PYTAN:
- Mix poziomow Blooma: 60% remembering/understanding, 40% applying/analyzing
- Mix trudnosci: 40% easy, 40% medium, 20% hard
- Kazde pytanie testuje jeden konkretny koncept

WYJASNIENIA BLEDOW:
Dla kazdej blednej odpowiedzi wyjasn DLACZEGO jest bledna.
Nie tylko "to jest niepoprawne" - wytlumacz roznice.

FORMAT ODPOWIEDZI:
- ID opcji: a, b, c, d (dla MCQ) lub a, b (dla true/false gdzie a=Prawda, b=Falsz)
- ID pytan: q-1, q-2, q-3...
`;

export const LEVEL_TEST_PROMPT = `Jestes ekspertem w tworzeniu testow koncowych.

ZADANIE: Wygeneruj kompleksowy test sprawdzajacy opanowanie poziomu.

ZASADY:
1. Test musi obejmowac WSZYSTKIE kluczowe tematy poziomu
2. Wiekszy nacisk na applying/analyzing niz w quizach sekcyjnych
3. Pytania powinny laczyc wiedze z roznych rozdzialow
4. Prog zaliczenia: 70% poprawnych odpowiedzi

STRUKTURA:
- 10-15 pytan
- Kazdy glowny temat poziomu reprezentowany
- Progresja trudnosci (latwiejsze na poczatku)
- Ostatnie 2-3 pytania integrujace wiedze

MASTERY INDICATORS:
Po zdaniu testu uzytkownik powinien umiec:
- [lista konkretnych umiejetnosci]
`;

export const REMEDIATION_PROMPT = `Jestes cierpliwym nauczycielem pomagajacym uczniowi zrozumiec trudny material.

ZADANIE: Przygotuj krotki material remediacyjny dla konceptow, ktore uczen zle zrozumial.

ZASADY:
1. NIE powtarzaj tego samego wyjasnienia
2. Uzyj innych slow, innych przykladow
3. Zacznij od NAJPROSTSZEGO wyjasnienia
4. Dodaj praktyczny przyklad z zycia
5. Podaj wskazowki jak zapamietac

FORMAT:
- Max 500 slow na koncept
- Prosty jezyk, bez zargonu
- Konkretne przyklady
`;
```

Prompts sa w jezyku polskim (zgodnie z projektem).
  </action>
  <verify>
- Plik istnieje i eksportuje 3 prompty
- Import dziala: `import { QUIZ_GENERATION_PROMPT } from '@/lib/ai/quiz/prompts'`
  </verify>
  <done>
- 3 prompty: QUIZ_GENERATION_PROMPT, LEVEL_TEST_PROMPT, REMEDIATION_PROMPT
- Prompty w jezyku polskim
- Eksportowane dla uzycia w API routes
  </done>
</task>

<task type="auto">
  <name>Task 2: DAL functions dla quizzes</name>
  <files>src/lib/dal/quizzes.ts</files>
  <action>
Utworz DAL dla quiz operations (wzorzec z dal/materials.ts i dal/courses.ts):

```typescript
/**
 * Data Access Layer - Quizzes
 * CRUD operations dla quizow i prob
 */
import { createClient } from "@/lib/supabase/server";
import type { Quiz, QuizAttempt, QuizQuestion, QuizRow, QuizAttemptRow } from "@/types/quiz";

// Row -> Application type conversion helpers
function quizRowToQuiz(row: QuizRow): Quiz { ... }
function attemptRowToAttempt(row: QuizAttemptRow): QuizAttempt { ... }

/**
 * Zapisz wygenerowany quiz do bazy
 */
export async function saveQuiz(input: {
  chapterId?: string;
  levelId?: string;
  quizType: 'section' | 'level_test';
  questions: QuizQuestion[];
  questionCount: number;
  estimatedMinutes: number;
  generationModel: string;
}): Promise<Quiz> {
  // Insert do quizzes table
  // Znajdz najwyzsza wersje i zwieksz o 1
  // Return saved quiz
}

/**
 * Pobierz quiz po ID
 */
export async function getQuiz(quizId: string): Promise<Quiz | null> {
  // SELECT * FROM quizzes WHERE id = quizId
}

/**
 * Pobierz najnowszy quiz dla rozdzialu
 */
export async function getQuizByChapter(chapterId: string): Promise<Quiz | null> {
  // SELECT * FROM quizzes WHERE chapter_id = chapterId
  // ORDER BY version DESC LIMIT 1
}

/**
 * Pobierz najnowszy test dla poziomu
 */
export async function getLevelTest(levelId: string): Promise<Quiz | null> {
  // SELECT * FROM quizzes WHERE level_id = levelId AND quiz_type = 'level_test'
  // ORDER BY version DESC LIMIT 1
}

/**
 * Utworz nowa probe quizu
 */
export async function createAttempt(
  userId: string,
  quizId: string
): Promise<QuizAttempt> {
  // INSERT INTO quiz_attempts (user_id, quiz_id, started_at)
  // Return created attempt
}

/**
 * Przeslij odpowiedzi i oblicz score
 */
export async function submitAttempt(
  attemptId: string,
  answers: Record<string, string>,
  quiz: Quiz
): Promise<{
  attempt: QuizAttempt;
  results: QuizResults;
}> {
  // Calculate score by comparing answers to quiz.questions
  // Update attempt with score, correct_count, passed, submitted_at
  // Return attempt and detailed results
}

/**
 * Pobierz historie prob uzytkownika dla quizu
 */
export async function getAttemptHistory(
  userId: string,
  quizId: string
): Promise<QuizAttempt[]> {
  // SELECT * FROM quiz_attempts WHERE user_id AND quiz_id
  // ORDER BY created_at DESC
}

/**
 * Sprawdz czy uzytkownik zdalal test poziomu
 */
export async function hasPassedLevelTest(
  userId: string,
  levelId: string
): Promise<boolean> {
  // Check quiz_attempts for level_test with passed = true
}

/**
 * Zapisz content remediacji
 */
export async function saveRemediation(
  attemptId: string,
  remediationContent: object
): Promise<void> {
  // UPDATE quiz_attempts SET remediation_content, remediation_viewed = false
}

/**
 * Oznacz remediacjie jako przejrzana
 */
export async function markRemediationViewed(attemptId: string): Promise<void> {
  // UPDATE quiz_attempts SET remediation_viewed = true
}
```

Uzyj wzorca z dal/materials.ts:
- createClient() z @/lib/supabase/server
- Error handling z throw new Error
- Row to Application type conversion
  </action>
  <verify>
- Plik istnieje i eksportuje wszystkie funkcje
- `npx tsc --noEmit` passes
- Import dziala: `import { saveQuiz, getQuizByChapter } from '@/lib/dal/quizzes'`
  </verify>
  <done>
- 10 DAL functions dla quiz CRUD
- Score calculation w submitAttempt
- Attempt history tracking
- TypeScript types poprawne
  </done>
</task>

<task type="auto">
  <name>Task 3: API endpoints dla quiz operations</name>
  <files>src/app/api/quiz/generate/route.ts, src/app/api/quiz/submit/route.ts</files>
  <action>
**src/app/api/quiz/generate/route.ts:**

Lazy generation endpoint (wzorzec z materials/generate/route.ts):

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { generateObject } from 'ai';
import { z } from 'zod';
import { getModel } from '@/lib/ai/providers';
import { quizSchema, levelTestSchema } from '@/lib/ai/quiz/schemas';
import { QUIZ_GENERATION_PROMPT, LEVEL_TEST_PROMPT } from '@/lib/ai/quiz/prompts';
import { saveQuiz, getQuizByChapter, getLevelTest } from '@/lib/dal/quizzes';
import { getSectionContent } from '@/lib/dal/materials';
import { getCourse } from '@/lib/dal/courses';
import { getCurrentUser } from '@/lib/dal/auth';

const requestSchema = z.object({
  chapterId: z.string().uuid().optional(),
  levelId: z.string().uuid().optional(),
  courseId: z.string().uuid(),
  forceRegenerate: z.boolean().optional().default(false),
}).refine(data => data.chapterId || data.levelId, {
  message: "Either chapterId or levelId required"
});

export async function POST(request: NextRequest) {
  // 1. Auth check
  const user = await getCurrentUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  // 2. Parse request
  const body = await request.json();
  const parsed = requestSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  }

  const { chapterId, levelId, courseId, forceRegenerate } = parsed.data;
  const isLevelTest = !!levelId;

  // 3. Check for existing quiz (lazy generation)
  if (!forceRegenerate) {
    const existing = isLevelTest
      ? await getLevelTest(levelId!)
      : await getQuizByChapter(chapterId!);
    if (existing) {
      return NextResponse.json({ quiz: existing, cached: true });
    }
  }

  // 4. Get context for generation
  // For section quiz: get chapter content
  // For level test: get all chapters in level + level outcomes

  // 5. Generate quiz
  const schema = isLevelTest ? levelTestSchema : quizSchema;
  const prompt = isLevelTest ? LEVEL_TEST_PROMPT : QUIZ_GENERATION_PROMPT;

  const { object } = await generateObject({
    model: getModel('curriculum'),
    schema,
    system: prompt,
    prompt: `...context...`,
  });

  // 6. Save to database
  const savedQuiz = await saveQuiz({
    chapterId,
    levelId,
    quizType: isLevelTest ? 'level_test' : 'section',
    questions: object.questions,
    questionCount: object.questions.length,
    estimatedMinutes: object.estimatedMinutes,
    generationModel: 'gpt-4',
  });

  return NextResponse.json({ quiz: savedQuiz, cached: false });
}
```

**src/app/api/quiz/submit/route.ts:**

Submit i evaluate endpoint:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getQuiz, createAttempt, submitAttempt } from '@/lib/dal/quizzes';
import { getCurrentUser } from '@/lib/dal/auth';

const requestSchema = z.object({
  quizId: z.string().uuid(),
  answers: z.record(z.string(), z.string()), // questionId -> optionId
});

export async function POST(request: NextRequest) {
  // 1. Auth check
  const user = await getCurrentUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  // 2. Parse request
  const body = await request.json();
  const parsed = requestSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  }

  const { quizId, answers } = parsed.data;

  // 3. Get quiz
  const quiz = await getQuiz(quizId);
  if (!quiz) {
    return NextResponse.json({ error: 'Quiz not found' }, { status: 404 });
  }

  // 4. Create attempt and calculate score
  const attempt = await createAttempt(user.id, quizId);
  const { attempt: finalAttempt, results } = await submitAttempt(
    attempt.id,
    answers,
    quiz
  );

  // 5. Return results with explanations
  return NextResponse.json({
    attempt: finalAttempt,
    results,
  });
}
```

Oba endpoints:
- Auth check z getCurrentUser
- Zod validation
- Error handling
- Return JSON responses
  </action>
  <verify>
- Pliki istnieja w api/quiz/
- `npx tsc --noEmit` passes
- Endpoints eksportuja POST
  </verify>
  <done>
- /api/quiz/generate - lazy generation z cache
- /api/quiz/submit - submit answers, calculate score
- Auth protected
- Zod validated
  </done>
</task>

</tasks>

<verification>
1. `ls src/lib/ai/quiz/prompts.ts` - prompts exist
2. `ls src/lib/dal/quizzes.ts` - DAL exists
3. `ls src/app/api/quiz/generate/route.ts` - generate endpoint exists
4. `ls src/app/api/quiz/submit/route.ts` - submit endpoint exists
5. `npx tsc --noEmit` - compiles without errors
</verification>

<success_criteria>
- AI prompts dla quiz generation
- DAL z 10 funkcjami dla quiz operations
- API endpoint /api/quiz/generate z lazy generation
- API endpoint /api/quiz/submit z scoring
- Server-side answer evaluation (anti-cheat)
- TypeScript kompiluje bez bledow
</success_criteria>

<output>
After completion, create `.planning/phases/04-assessment-system/04-02-SUMMARY.md`
</output>
