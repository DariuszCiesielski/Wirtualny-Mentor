---
phase: 04-assessment-system
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/components/quiz/quiz-question.tsx
  - src/components/quiz/quiz-container.tsx
  - src/components/quiz/quiz-results.tsx
  - src/components/quiz/quiz-feedback.tsx
  - src/app/(dashboard)/courses/[courseId]/[levelId]/[chapterId]/quiz/page.tsx
autonomous: true

must_haves:
  truths:
    - "Uzytkownik moze rozwiazywac quiz z pojedynczymi pytaniami"
    - "Uzytkownik widzi feedback po wyslaniu odpowiedzi"
    - "Uzytkownik widzi podsumowanie wynikow po zakonczeniu"
    - "Quiz loading state pokazuje generowanie"
  artifacts:
    - path: "src/components/quiz/quiz-question.tsx"
      provides: "Single question component"
      exports: ["QuizQuestion"]
    - path: "src/components/quiz/quiz-container.tsx"
      provides: "Quiz flow management"
      exports: ["QuizContainer"]
    - path: "src/components/quiz/quiz-results.tsx"
      provides: "Results summary"
      exports: ["QuizResults"]
    - path: "src/components/quiz/quiz-feedback.tsx"
      provides: "Answer feedback"
      exports: ["QuizFeedback"]
    - path: "src/app/(dashboard)/courses/[courseId]/[levelId]/[chapterId]/quiz/page.tsx"
      provides: "Quiz page route"
  key_links:
    - from: "src/components/quiz/quiz-container.tsx"
      to: "/api/quiz/generate"
      via: "fetch in useEffect"
      pattern: "fetch.*api/quiz/generate"
    - from: "src/components/quiz/quiz-container.tsx"
      to: "/api/quiz/submit"
      via: "fetch on submit"
      pattern: "fetch.*api/quiz/submit"
---

<objective>
Zbudowac UI dla rozwiazywania quizow z feedbackiem i wynikami.

Purpose: UI pozwala uzytkownikowi na interakcje z quizami i widzenie wynikow.
Output: Komponenty quiz, strona quiz w chapter routing.
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-assessment-system/04-RESEARCH.md
@.planning/phases/04-assessment-system/04-01-SUMMARY.md
@.planning/phases/04-assessment-system/04-02-SUMMARY.md
@src/components/materials/chapter-content.tsx
@src/components/ui/card.tsx
@src/components/ui/button.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Quiz question i feedback components</name>
  <files>src/components/quiz/quiz-question.tsx, src/components/quiz/quiz-feedback.tsx</files>
  <action>
**src/components/quiz/quiz-question.tsx:**

Komponent pojedynczego pytania (wzorzec z research + shadcn/ui):

```tsx
'use client';

import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { CheckCircle, XCircle } from 'lucide-react';
import type { QuizQuestion as QuizQuestionType } from '@/types/quiz';

interface QuizQuestionProps {
  question: QuizQuestionType;
  questionNumber: number;
  totalQuestions: number;
  selectedOption: string | null;
  onSelect: (optionId: string) => void;
  showFeedback: boolean;
  disabled: boolean;
}

export function QuizQuestion({
  question,
  questionNumber,
  totalQuestions,
  selectedOption,
  onSelect,
  showFeedback,
  disabled,
}: QuizQuestionProps) {
  const isCorrect = selectedOption === question.correctOptionId;

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle className="text-lg">
          Pytanie {questionNumber} z {totalQuestions}
        </CardTitle>
        <div className="flex gap-2">
          <Badge variant="outline">{question.difficulty}</Badge>
          <Badge variant="secondary">{question.bloomLevel}</Badge>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        <p className="text-lg font-medium">{question.question}</p>

        <RadioGroup
          value={selectedOption ?? undefined}
          onValueChange={onSelect}
          disabled={disabled}
          className="space-y-3"
        >
          {question.options.map((option) => {
            const isSelected = selectedOption === option.id;
            const isCorrectOption = option.id === question.correctOptionId;

            let optionClass = 'border rounded-lg p-3 transition-colors';
            if (showFeedback && isSelected) {
              optionClass += isCorrectOption
                ? ' border-green-500 bg-green-50 dark:bg-green-950'
                : ' border-red-500 bg-red-50 dark:bg-red-950';
            } else if (showFeedback && isCorrectOption) {
              optionClass += ' border-green-500';
            } else if (isSelected) {
              optionClass += ' border-primary';
            }

            return (
              <div key={option.id} className={optionClass}>
                <div className="flex items-center space-x-3">
                  <RadioGroupItem value={option.id} id={option.id} />
                  <Label htmlFor={option.id} className="flex-1 cursor-pointer">
                    <span className="font-medium mr-2">{option.id.toUpperCase()}.</span>
                    {option.text}
                  </Label>
                  {showFeedback && isSelected && (
                    isCorrectOption
                      ? <CheckCircle className="h-5 w-5 text-green-600" />
                      : <XCircle className="h-5 w-5 text-red-600" />
                  )}
                </div>
              </div>
            );
          })}
        </RadioGroup>

        {/* Inline feedback po odpowiedzi */}
        {showFeedback && selectedOption && (
          <QuizFeedback
            isCorrect={isCorrect}
            explanation={question.explanation}
            wrongExplanation={
              !isCorrect ? question.wrongExplanations[selectedOption] : undefined
            }
          />
        )}
      </CardContent>
    </Card>
  );
}
```

**src/components/quiz/quiz-feedback.tsx:**

Komponent feedback dla odpowiedzi:

```tsx
'use client';

import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { CheckCircle, XCircle, Lightbulb } from 'lucide-react';

interface QuizFeedbackProps {
  isCorrect: boolean;
  explanation: string;
  wrongExplanation?: string;
}

export function QuizFeedback({
  isCorrect,
  explanation,
  wrongExplanation,
}: QuizFeedbackProps) {
  return (
    <Alert variant={isCorrect ? 'default' : 'destructive'} className="mt-4">
      <div className="flex items-start gap-3">
        {isCorrect ? (
          <CheckCircle className="h-5 w-5 text-green-600 mt-0.5" />
        ) : (
          <XCircle className="h-5 w-5 mt-0.5" />
        )}
        <div className="flex-1">
          <AlertTitle className="mb-2">
            {isCorrect ? 'Poprawnie!' : 'Niepoprawnie'}
          </AlertTitle>
          <AlertDescription className="space-y-2">
            {!isCorrect && wrongExplanation && (
              <p className="text-sm">{wrongExplanation}</p>
            )}
            <div className="flex items-start gap-2 mt-2 p-2 bg-muted rounded">
              <Lightbulb className="h-4 w-4 mt-0.5 flex-shrink-0" />
              <p className="text-sm">{explanation}</p>
            </div>
          </AlertDescription>
        </div>
      </div>
    </Alert>
  );
}
```

Cechy:
- RadioGroup dla wyboru odpowiedzi
- Visual feedback (green/red) po odpowiedzi
- Badge dla difficulty i bloom level
- Ikony CheckCircle/XCircle
- Explanation w Alert component
  </action>
  <verify>
- Pliki istnieja w src/components/quiz/
- `npx tsc --noEmit` passes
- Komponenty uzywaja shadcn/ui components
  </verify>
  <done>
- QuizQuestion z RadioGroup i visual feedback
- QuizFeedback z Alert i explanations
- Poprawne importy z @/components/ui
  </done>
</task>

<task type="auto">
  <name>Task 2: Quiz container i results components</name>
  <files>src/components/quiz/quiz-container.tsx, src/components/quiz/quiz-results.tsx</files>
  <action>
**src/components/quiz/quiz-container.tsx:**

Glowny container zarzadzajacy flow quizu:

```tsx
'use client';

import { useState, useEffect, useReducer } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';
import { Loader2, ArrowRight, RotateCcw, CheckSquare } from 'lucide-react';
import { QuizQuestion } from './quiz-question';
import { QuizResults } from './quiz-results';
import type { Quiz, QuizResults as QuizResultsType } from '@/types/quiz';

interface QuizContainerProps {
  chapterId?: string;
  levelId?: string;
  courseId: string;
  chapterTitle?: string;
  levelName?: string;
  onComplete?: (passed: boolean) => void;
}

type QuizState =
  | { status: 'loading' }
  | { status: 'error'; message: string }
  | { status: 'ready'; quiz: Quiz }
  | { status: 'in_progress'; quiz: Quiz; currentIndex: number; answers: Record<string, string>; showFeedback: boolean }
  | { status: 'submitting'; quiz: Quiz; answers: Record<string, string> }
  | { status: 'completed'; quiz: Quiz; results: QuizResultsType };

type QuizAction =
  | { type: 'LOADED'; quiz: Quiz }
  | { type: 'ERROR'; message: string }
  | { type: 'START' }
  | { type: 'ANSWER'; questionId: string; optionId: string }
  | { type: 'SHOW_FEEDBACK' }
  | { type: 'NEXT' }
  | { type: 'SUBMIT' }
  | { type: 'RESULTS'; results: QuizResultsType }
  | { type: 'RETRY' };

function quizReducer(state: QuizState, action: QuizAction): QuizState {
  // Reducer implementation...
}

export function QuizContainer({
  chapterId,
  levelId,
  courseId,
  chapterTitle,
  levelName,
  onComplete,
}: QuizContainerProps) {
  const [state, dispatch] = useReducer(quizReducer, { status: 'loading' });

  // Load quiz on mount
  useEffect(() => {
    async function loadQuiz() {
      try {
        const res = await fetch('/api/quiz/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ chapterId, levelId, courseId }),
        });
        if (!res.ok) throw new Error('Failed to load quiz');
        const data = await res.json();
        dispatch({ type: 'LOADED', quiz: data.quiz });
      } catch (error) {
        dispatch({ type: 'ERROR', message: 'Nie udalo sie zaladowac quizu' });
      }
    }
    loadQuiz();
  }, [chapterId, levelId, courseId]);

  // Submit answers
  async function handleSubmit() {
    if (state.status !== 'in_progress') return;
    dispatch({ type: 'SUBMIT' });

    try {
      const res = await fetch('/api/quiz/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          quizId: state.quiz.id,
          answers: state.answers,
        }),
      });
      if (!res.ok) throw new Error('Submit failed');
      const data = await res.json();
      dispatch({ type: 'RESULTS', results: data.results });
      onComplete?.(data.results.passed);
    } catch (error) {
      dispatch({ type: 'ERROR', message: 'Nie udalo sie wyslac odpowiedzi' });
    }
  }

  // Render based on state...
  if (state.status === 'loading') {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <Loader2 className="h-8 w-8 animate-spin mb-4" />
          <p>Ladowanie quizu...</p>
        </CardContent>
      </Card>
    );
  }

  if (state.status === 'error') {
    return (
      <Card>
        <CardContent className="py-8 text-center">
          <p className="text-destructive">{state.message}</p>
          <Button onClick={() => window.location.reload()} className="mt-4">
            Sprobuj ponownie
          </Button>
        </CardContent>
      </Card>
    );
  }

  if (state.status === 'completed') {
    return (
      <QuizResults
        results={state.results}
        quiz={state.quiz}
        onRetry={() => dispatch({ type: 'RETRY' })}
      />
    );
  }

  // Quiz in progress...
  const quiz = state.quiz;
  const currentQuestion = quiz.questions[state.currentIndex];
  const progress = ((state.currentIndex + 1) / quiz.questions.length) * 100;

  return (
    <div className="space-y-4">
      <Progress value={progress} className="h-2" />

      <QuizQuestion
        question={currentQuestion}
        questionNumber={state.currentIndex + 1}
        totalQuestions={quiz.questions.length}
        selectedOption={state.answers[currentQuestion.id] ?? null}
        onSelect={(optionId) => dispatch({
          type: 'ANSWER',
          questionId: currentQuestion.id,
          optionId,
        })}
        showFeedback={state.showFeedback}
        disabled={state.showFeedback}
      />

      <div className="flex justify-between">
        {!state.showFeedback ? (
          <Button
            onClick={() => dispatch({ type: 'SHOW_FEEDBACK' })}
            disabled={!state.answers[currentQuestion.id]}
          >
            Sprawdz odpowiedz
          </Button>
        ) : state.currentIndex < quiz.questions.length - 1 ? (
          <Button onClick={() => dispatch({ type: 'NEXT' })}>
            Nastepne pytanie <ArrowRight className="ml-2 h-4 w-4" />
          </Button>
        ) : (
          <Button onClick={handleSubmit}>
            <CheckSquare className="mr-2 h-4 w-4" />
            Zakoncz quiz
          </Button>
        )}
      </div>
    </div>
  );
}
```

**src/components/quiz/quiz-results.tsx:**

Podsumowanie wynikow:

```tsx
'use client';

import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Badge } from '@/components/ui/badge';
import { Trophy, XCircle, RotateCcw, ArrowRight } from 'lucide-react';
import type { Quiz, QuizResults as QuizResultsType } from '@/types/quiz';

interface QuizResultsProps {
  results: QuizResultsType;
  quiz: Quiz;
  onRetry: () => void;
  onContinue?: () => void;
}

export function QuizResults({
  results,
  quiz,
  onRetry,
  onContinue,
}: QuizResultsProps) {
  const passThreshold = quiz.passThreshold ?? 0.7;
  const scorePercent = Math.round(results.score);

  return (
    <Card>
      <CardHeader className="text-center">
        <div className="flex justify-center mb-4">
          {results.passed ? (
            <Trophy className="h-16 w-16 text-yellow-500" />
          ) : (
            <XCircle className="h-16 w-16 text-destructive" />
          )}
        </div>
        <CardTitle className="text-2xl">
          {results.passed ? 'Gratulacje!' : 'Nie tym razem'}
        </CardTitle>
      </CardHeader>

      <CardContent className="space-y-6">
        <div className="text-center">
          <p className="text-4xl font-bold mb-2">{scorePercent}%</p>
          <p className="text-muted-foreground">
            {results.correctCount} z {results.totalCount} poprawnych
          </p>
        </div>

        <Progress value={scorePercent} className="h-3" />

        <div className="flex justify-center gap-4">
          <Badge variant={results.passed ? 'default' : 'secondary'}>
            Prog zaliczenia: {Math.round(passThreshold * 100)}%
          </Badge>
          <Badge variant={results.passed ? 'default' : 'destructive'}>
            {results.passed ? 'ZALICZONE' : 'NIEZALICZONE'}
          </Badge>
        </div>

        {/* Szczegoly odpowiedzi */}
        <div className="space-y-2">
          <h4 className="font-medium">Podsumowanie odpowiedzi:</h4>
          {results.questionResults.map((qr, index) => (
            <div
              key={qr.questionId}
              className={`flex items-center justify-between p-2 rounded ${
                qr.isCorrect ? 'bg-green-50 dark:bg-green-950' : 'bg-red-50 dark:bg-red-950'
              }`}
            >
              <span>Pytanie {index + 1}</span>
              {qr.isCorrect ? (
                <Badge variant="outline" className="bg-green-100 dark:bg-green-900">
                  Poprawne
                </Badge>
              ) : (
                <Badge variant="outline" className="bg-red-100 dark:bg-red-900">
                  Bledne
                </Badge>
              )}
            </div>
          ))}
        </div>
      </CardContent>

      <CardFooter className="flex gap-4 justify-center">
        <Button variant="outline" onClick={onRetry}>
          <RotateCcw className="mr-2 h-4 w-4" />
          Sprobuj ponownie
        </Button>
        {results.passed && onContinue && (
          <Button onClick={onContinue}>
            Kontynuuj <ArrowRight className="ml-2 h-4 w-4" />
          </Button>
        )}
      </CardFooter>
    </Card>
  );
}
```

Cechy:
- State machine dla quiz flow
- Progress bar
- Loading state
- Error handling
- Results summary z score i details
  </action>
  <verify>
- Pliki istnieja
- `npx tsc --noEmit` passes
- QuizContainer fetch z /api/quiz/*
  </verify>
  <done>
- QuizContainer z useReducer state machine
- QuizResults z score summary
- Loading, error, completed states
- Fetch integration z API endpoints
  </done>
</task>

<task type="auto">
  <name>Task 3: Quiz page route</name>
  <files>src/app/(dashboard)/courses/[courseId]/[levelId]/[chapterId]/quiz/page.tsx</files>
  <action>
Strona quizu dostepna po ukonczeniu rozdzialu:

```tsx
import { notFound } from 'next/navigation';
import { getCourse } from '@/lib/dal/courses';
import { getCurrentUser } from '@/lib/dal/auth';
import { QuizContainer } from '@/components/quiz/quiz-container';

interface QuizPageProps {
  params: Promise<{
    courseId: string;
    levelId: string;
    chapterId: string;
  }>;
}

export default async function QuizPage({ params }: QuizPageProps) {
  const { courseId, levelId, chapterId } = await params;

  // Auth check
  const user = await getCurrentUser();
  if (!user) {
    notFound();
  }

  // Get course for context
  const course = await getCourse(courseId);
  if (!course || course.user_id !== user.id) {
    notFound();
  }

  // Find chapter title
  const level = course.course_levels?.find(l => l.id === levelId);
  const chapter = level?.chapters?.find(c => c.id === chapterId);

  if (!chapter) {
    notFound();
  }

  return (
    <div className="container max-w-3xl py-8">
      <div className="mb-6">
        <h1 className="text-2xl font-bold">Quiz: {chapter.title}</h1>
        <p className="text-muted-foreground">
          Sprawdz swoje zrozumienie materialu
        </p>
      </div>

      <QuizContainer
        chapterId={chapterId}
        courseId={courseId}
        chapterTitle={chapter.title}
      />
    </div>
  );
}
```

Strona:
- Server component z auth check
- Pobiera context (chapter title)
- Renderuje QuizContainer client component
- Route: /courses/[courseId]/[levelId]/[chapterId]/quiz
  </action>
  <verify>
- Plik istnieje w poprawnej lokalizacji
- `npx tsc --noEmit` passes
- Route dziala (manual test)
  </verify>
  <done>
- Quiz page z auth check
- Pobiera chapter context
- Renderuje QuizContainer
- Route nested w chapter routing
  </done>
</task>

</tasks>

<verification>
1. `ls src/components/quiz/` - 4 komponenty istnieja
2. `ls src/app/(dashboard)/courses/[courseId]/[levelId]/[chapterId]/quiz/page.tsx`
3. `npx tsc --noEmit` - kompiluje bez bledow
4. Visual check: quiz page renderuje sie poprawnie (manual test)
</verification>

<success_criteria>
- 4 komponenty quiz w src/components/quiz/
- Quiz page route dziala
- Quiz flow: load -> answer -> feedback -> next -> results
- Visual feedback (green/red) dla odpowiedzi
- Results summary z score i passed/failed
- TypeScript kompiluje
</success_criteria>

<output>
After completion, create `.planning/phases/04-assessment-system/04-03-SUMMARY.md`
</output>
