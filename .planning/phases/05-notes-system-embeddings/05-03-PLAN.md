---
phase: 05-notes-system-embeddings
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/lib/dal/notes.ts
  - src/app/(dashboard)/courses/[courseId]/[levelId]/[chapterId]/actions.ts
autonomous: true

must_haves:
  truths:
    - "Uzytkownik moze tworzyc notatki z automatycznym embedowaniem"
    - "Uzytkownik moze edytowac notatki z re-embedowaniem"
    - "Uzytkownik moze usuwac notatki"
    - "Notatki sa przeszukiwalne przez full-text search"
    - "Notatki sa przeszukiwalne przez vector similarity"
  artifacts:
    - path: "src/lib/dal/notes.ts"
      provides: "Notes CRUD and search functions"
      exports: ["createNote", "updateNote", "deleteNote", "getNotes", "searchNotesFulltext", "searchNotesSemantic"]
    - path: "src/app/(dashboard)/courses/[courseId]/[levelId]/[chapterId]/actions.ts"
      provides: "Server Actions for notes"
      exports: ["createNoteAction", "updateNoteAction", "deleteNoteAction"]
  key_links:
    - from: "actions.ts"
      to: "dal/notes.ts"
      via: "import createNote"
      pattern: "import.*createNote.*from.*dal/notes"
    - from: "dal/notes.ts"
      to: "lib/ai/embeddings.ts"
      via: "import generateEmbedding"
      pattern: "import.*generateEmbedding.*from.*embeddings"
---

<objective>
Implementacja DAL i Server Actions dla CRUD notatek z synchronicznym embedowaniem.

Purpose: Kazda notatka musi miec embedding wygenerowany przy zapisie. Ten plan laczy logike bazodanowa z generowaniem embeddingow.

Output: Kompletny backend dla notatek - DAL functions + Server Actions gotowe do podpiecia UI.
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-notes-system-embeddings/05-RESEARCH.md

# Dependencies from this phase:
@src/types/notes.ts
@src/lib/ai/embeddings.ts

# Existing patterns:
@src/lib/dal/courses.ts
@src/lib/dal/materials.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notes DAL</name>
  <files>src/lib/dal/notes.ts</files>
  <action>
Utworz Data Access Layer dla notatek:

```typescript
/**
 * Data Access Layer - Notes
 *
 * CRUD operations for user notes with embedding generation.
 * All functions use Supabase server client and require authentication.
 */

import { createClient } from '@/lib/supabase/server';
import { generateEmbedding, EMBEDDING_MODEL_ID } from '@/lib/ai/embeddings';
import type {
  Note,
  NoteWithContext,
  CreateNoteInput,
  UpdateNoteInput,
  NoteSimilarityResult,
  NoteSearchResult,
} from '@/types/notes';

/**
 * Create a new note with embedding
 *
 * Embedding is generated synchronously at write time.
 */
export async function createNote(
  userId: string,
  input: CreateNoteInput
): Promise<Note> {
  const supabase = await createClient();

  // Generate embedding for content
  const embedding = await generateEmbedding(input.content);

  const { data, error } = await supabase
    .from('notes')
    .insert({
      user_id: userId,
      course_id: input.course_id,
      chapter_id: input.chapter_id ?? null,
      content: input.content,
      embedding: JSON.stringify(embedding),
      embedding_model: EMBEDDING_MODEL_ID,
    })
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to create note: ${error.message}`);
  }

  return data as Note;
}

/**
 * Update a note - re-generates embedding
 */
export async function updateNote(
  noteId: string,
  userId: string,
  input: UpdateNoteInput
): Promise<Note> {
  const supabase = await createClient();

  // Re-generate embedding for updated content
  const embedding = await generateEmbedding(input.content);

  const { data, error } = await supabase
    .from('notes')
    .update({
      content: input.content,
      embedding: JSON.stringify(embedding),
      embedding_model: EMBEDDING_MODEL_ID,
    })
    .eq('id', noteId)
    .eq('user_id', userId)
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to update note: ${error.message}`);
  }

  return data as Note;
}

/**
 * Delete a note
 */
export async function deleteNote(noteId: string, userId: string): Promise<void> {
  const supabase = await createClient();

  const { error } = await supabase
    .from('notes')
    .delete()
    .eq('id', noteId)
    .eq('user_id', userId);

  if (error) {
    throw new Error(`Failed to delete note: ${error.message}`);
  }
}

/**
 * Get all notes for a course
 */
export async function getNotes(
  userId: string,
  courseId: string,
  chapterId?: string
): Promise<Note[]> {
  const supabase = await createClient();

  let query = supabase
    .from('notes')
    .select('*')
    .eq('user_id', userId)
    .eq('course_id', courseId)
    .order('created_at', { ascending: false });

  if (chapterId) {
    query = query.eq('chapter_id', chapterId);
  }

  const { data, error } = await query;

  if (error) {
    throw new Error(`Failed to get notes: ${error.message}`);
  }

  return data as Note[];
}

/**
 * Get notes with context (chapter title, level name)
 */
export async function getNotesWithContext(
  userId: string,
  courseId: string
): Promise<NoteWithContext[]> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('notes')
    .select(`
      *,
      chapters!chapter_id (
        title,
        course_levels!level_id (
          name
        )
      ),
      courses!course_id (
        title
      )
    `)
    .eq('user_id', userId)
    .eq('course_id', courseId)
    .order('created_at', { ascending: false });

  if (error) {
    throw new Error(`Failed to get notes with context: ${error.message}`);
  }

  // Transform nested data
  return (data ?? []).map((note) => ({
    ...note,
    chapter_title: note.chapters?.title ?? null,
    level_name: note.chapters?.course_levels?.name ?? null,
    course_title: note.courses?.title ?? null,
    chapters: undefined,
    courses: undefined,
  })) as NoteWithContext[];
}

/**
 * Full-text search in notes (for UI)
 *
 * Uses PostgreSQL tsvector with 'simple' config
 */
export async function searchNotesFulltext(
  userId: string,
  courseId: string,
  query: string,
  limit = 10
): Promise<NoteSearchResult[]> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('notes')
    .select('*')
    .eq('user_id', userId)
    .eq('course_id', courseId)
    .textSearch('fts', query, {
      type: 'plain',
      config: 'simple',
    })
    .limit(limit);

  if (error) {
    throw new Error(`Failed to search notes: ${error.message}`);
  }

  return data as NoteSearchResult[];
}

/**
 * Vector similarity search (for RAG chatbot)
 *
 * Requires RPC function search_notes_semantic in database.
 */
export async function searchNotesSemantic(
  userId: string,
  courseId: string,
  queryText: string,
  threshold = 0.7,
  limit = 5
): Promise<NoteSimilarityResult[]> {
  const supabase = await createClient();

  // Generate embedding for query
  const queryEmbedding = await generateEmbedding(queryText);

  const { data, error } = await supabase.rpc('search_notes_semantic', {
    p_user_id: userId,
    p_course_id: courseId,
    p_embedding: JSON.stringify(queryEmbedding),
    p_match_threshold: threshold,
    p_match_count: limit,
  });

  if (error) {
    throw new Error(`Failed to semantic search notes: ${error.message}`);
  }

  return data as NoteSimilarityResult[];
}

/**
 * Get single note by ID
 */
export async function getNote(noteId: string, userId: string): Promise<Note | null> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('notes')
    .select('*')
    .eq('id', noteId)
    .eq('user_id', userId)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return null;
    }
    throw new Error(`Failed to get note: ${error.message}`);
  }

  return data as Note;
}
```

WAZNE:
- Embedding jest generowany synchronicznie przy createNote i updateNote
- JSON.stringify(embedding) dla przechowywania w Supabase
- RLS automatycznie filtruje po user_id
- searchNotesSemantic wymaga funkcji RPC w bazie (dodana w 05-01 migracji)
  </action>
  <verify>
`npx tsc --noEmit src/lib/dal/notes.ts` - brak bledow
  </verify>
  <done>
DAL dla notes gotowy z CRUD + dual search (fulltext + semantic).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Server Actions for notes</name>
  <files>src/app/(dashboard)/courses/[courseId]/[levelId]/[chapterId]/actions.ts</files>
  <action>
Utworz lub rozszerz plik actions.ts o Server Actions dla notatek:

```typescript
'use server';

import { revalidatePath } from 'next/cache';
import { createClient } from '@/lib/supabase/server';
import { createNote, updateNote, deleteNote } from '@/lib/dal/notes';
import type { CreateNoteInput } from '@/types/notes';

/**
 * Create a new note for the current chapter
 *
 * Server Action - generates embedding synchronously
 */
export async function createNoteAction(formData: FormData) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return { error: 'Unauthorized' };
  }

  const content = formData.get('content') as string;
  const courseId = formData.get('courseId') as string;
  const chapterId = formData.get('chapterId') as string | null;

  if (!content || content.trim().length === 0) {
    return { error: 'Content is required' };
  }

  if (!courseId) {
    return { error: 'Course ID is required' };
  }

  try {
    const input: CreateNoteInput = {
      course_id: courseId,
      chapter_id: chapterId || null,
      content: content.trim(),
    };

    const note = await createNote(user.id, input);

    revalidatePath(`/courses/${courseId}`);

    return { data: note };
  } catch (error) {
    console.error('Create note error:', error);
    return {
      error: error instanceof Error ? error.message : 'Failed to create note',
    };
  }
}

/**
 * Update an existing note
 *
 * Re-generates embedding for updated content
 */
export async function updateNoteAction(formData: FormData) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return { error: 'Unauthorized' };
  }

  const noteId = formData.get('noteId') as string;
  const content = formData.get('content') as string;
  const courseId = formData.get('courseId') as string;

  if (!noteId) {
    return { error: 'Note ID is required' };
  }

  if (!content || content.trim().length === 0) {
    return { error: 'Content is required' };
  }

  try {
    const note = await updateNote(noteId, user.id, {
      content: content.trim(),
    });

    revalidatePath(`/courses/${courseId}`);

    return { data: note };
  } catch (error) {
    console.error('Update note error:', error);
    return {
      error: error instanceof Error ? error.message : 'Failed to update note',
    };
  }
}

/**
 * Delete a note
 */
export async function deleteNoteAction(formData: FormData) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return { error: 'Unauthorized' };
  }

  const noteId = formData.get('noteId') as string;
  const courseId = formData.get('courseId') as string;

  if (!noteId) {
    return { error: 'Note ID is required' };
  }

  try {
    await deleteNote(noteId, user.id);

    revalidatePath(`/courses/${courseId}`);

    return { success: true };
  } catch (error) {
    console.error('Delete note error:', error);
    return {
      error: error instanceof Error ? error.message : 'Failed to delete note',
    };
  }
}
```

Jesli plik juz istnieje, dodaj te funkcje do istniejacych akcji.

WAZNE:
- Uzyj 'use server' na poczatku pliku
- Waliduj input (content required, nie pusty)
- revalidatePath po kazdej akcji
- Zwracaj { error } lub { data } dla client-side handling
  </action>
  <verify>
`npx tsc --noEmit src/app/\(dashboard\)/courses/\[courseId\]/\[levelId\]/\[chapterId\]/actions.ts` - brak bledow
  </verify>
  <done>
Server Actions dla notes gotowe do podpiecia w UI.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add RPC function to migration</name>
  <files>supabase/migrations/20260131200001_notes_schema.sql</files>
  <action>
Dodaj do migracji z 05-01 funkcje RPC dla vector similarity search:

```sql
-- Vector similarity search function for RAG
CREATE OR REPLACE FUNCTION search_notes_semantic(
  p_user_id UUID,
  p_course_id UUID,
  p_embedding TEXT,  -- JSON array of floats
  p_match_threshold FLOAT DEFAULT 0.7,
  p_match_count INT DEFAULT 5
)
RETURNS TABLE(
  id UUID,
  content TEXT,
  similarity FLOAT,
  chapter_id UUID
) AS $$
DECLARE
  v_embedding halfvec(1536);
BEGIN
  -- Parse JSON to halfvec
  v_embedding := p_embedding::halfvec(1536);

  RETURN QUERY
  SELECT
    notes.id,
    notes.content,
    1 - (notes.embedding <=> v_embedding) as similarity,
    notes.chapter_id
  FROM notes
  WHERE notes.user_id = p_user_id
    AND notes.course_id = p_course_id
    AND notes.embedding IS NOT NULL
    AND 1 - (notes.embedding <=> v_embedding) > p_match_threshold
  ORDER BY notes.embedding <=> v_embedding
  LIMIT p_match_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

Jesli plik juz istnieje (z Task 1), dodaj te funkcje na koncu pliku.

WAZNE:
- SECURITY DEFINER pozwala na wykonanie mimo RLS (funkcja jest zaufana)
- Parsuj JSON do halfvec w funkcji
- Cosine distance: `<=>` operator
- Similarity = 1 - distance
  </action>
  <verify>
Plik zawiera CREATE OR REPLACE FUNCTION search_notes_semantic
  </verify>
  <done>
Funkcja RPC dla semantic search gotowa.
  </done>
</task>

</tasks>

<verification>
1. DAL eksportuje: createNote, updateNote, deleteNote, getNotes, getNotesWithContext, searchNotesFulltext, searchNotesSemantic
2. Server Actions eksportuja: createNoteAction, updateNoteAction, deleteNoteAction
3. TypeScript kompiluje sie bez bledow
4. Migracja zawiera funkcje RPC search_notes_semantic
5. DAL importuje generateEmbedding z lib/ai/embeddings
</verification>

<success_criteria>
- Complete CRUD operations for notes
- Embedding generation at write time (sync)
- Dual search: fulltext (tsvector) + semantic (pgvector)
- Server Actions ready for UI integration
- RPC function for RAG chatbot ready
</success_criteria>

<output>
After completion, create `.planning/phases/05-notes-system-embeddings/05-03-SUMMARY.md`
</output>
