---
phase: 07-polish-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ai/providers.ts
  - src/lib/monitoring/helicone.ts
  - .env.local.example
autonomous: true

must_haves:
  truths:
    - "Wszystkie AI calls sa trackowane przez Helicone"
    - "Koszty i latency widoczne w Helicone dashboard"
    - "Istniejaca funkcjonalnosc AI dziala bez zmian"
  artifacts:
    - path: "src/lib/monitoring/helicone.ts"
      provides: "Helicone configuration i helper functions"
      exports: ["createHeliconeHeaders", "HELICONE_CONFIG"]
    - path: "src/lib/ai/providers.ts"
      provides: "AI providers z Helicone integration"
      contains: "helicone"
  key_links:
    - from: "src/lib/ai/providers.ts"
      to: "Helicone gateway"
      via: "baseURL configuration"
      pattern: "helicone"
---

<objective>
Zintegrowac Helicone dla monitorowania kosztow i latency wszystkich AI calls.

Purpose: Spelnienie wymagania o dashboardzie kosztow AI - Helicone zapewnia automatyczny tracking
Output: Wszystkie AI providery skonfigurowane z Helicone gateway
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-polish-optimization/07-RESEARCH.md

# Existing providers
@src/lib/ai/providers.ts

# Helicone integration pattern:
# - Change baseURL to https://[provider].helicone.ai
# - Add Helicone-Auth header with Bearer token
# - Provider functionality remains unchanged
</context>

<tasks>

<task type="auto">
  <name>Task 1: Utworz Helicone configuration module</name>
  <files>src/lib/monitoring/helicone.ts, .env.local.example</files>
  <action>
1. Utworz folder src/lib/monitoring/ jesli nie istnieje

2. Utworz src/lib/monitoring/helicone.ts:
```typescript
/**
 * Helicone LLM Observability Configuration
 *
 * Helicone provides automatic cost/latency tracking for all AI calls.
 * Dashboard: https://us.helicone.ai/dashboard
 */

// Helicone gateway URLs for each provider
export const HELICONE_GATEWAYS = {
  anthropic: 'https://anthropic.helicone.ai',
  openai: 'https://oai.helicone.ai/v1',
  google: 'https://gateway.helicone.ai',
} as const;

// Check if Helicone is enabled (has API key)
export function isHeliconeEnabled(): boolean {
  return !!process.env.HELICONE_API_KEY;
}

// Create Helicone auth headers
export function createHeliconeHeaders(options?: {
  sessionId?: string;
  userId?: string;
  metadata?: Record<string, string>;
}): Record<string, string> {
  const apiKey = process.env.HELICONE_API_KEY;
  if (!apiKey) return {};

  const headers: Record<string, string> = {
    'Helicone-Auth': `Bearer ${apiKey}`,
  };

  // Optional: Add session tracking
  if (options?.sessionId) {
    headers['Helicone-Session-Id'] = options.sessionId;
  }

  // Optional: Add user tracking
  if (options?.userId) {
    headers['Helicone-User-Id'] = options.userId;
  }

  // Optional: Add custom metadata
  if (options?.metadata) {
    Object.entries(options.metadata).forEach(([key, value]) => {
      headers[`Helicone-Property-${key}`] = value;
    });
  }

  return headers;
}
```

3. Zaktualizuj .env.local.example - dodaj na koncu:
```
# Helicone (optional - for cost monitoring)
# Get key from: https://us.helicone.ai/developer
HELICONE_API_KEY=
```
  </action>
  <verify>
- Plik src/lib/monitoring/helicone.ts istnieje
- Eksportuje HELICONE_GATEWAYS, isHeliconeEnabled, createHeliconeHeaders
- .env.local.example ma HELICONE_API_KEY
- `npm run build` przechodzi
  </verify>
  <done>Helicone configuration module gotowy</done>
</task>

<task type="auto">
  <name>Task 2: Zaktualizuj AI providers z Helicone gateway</name>
  <files>src/lib/ai/providers.ts</files>
  <action>
Zaktualizuj src/lib/ai/providers.ts aby uzyc Helicone gateway gdy klucz jest dostepny:

```typescript
// Provider Registry for Multi-Model AI
// Source: https://ai-sdk.dev/docs/ai-sdk-core/provider-management

import { createAnthropic } from '@ai-sdk/anthropic';
import { createOpenAI } from '@ai-sdk/openai';
import { createGoogleGenerativeAI } from '@ai-sdk/google';
import { experimental_createProviderRegistry as createProviderRegistry } from 'ai';
import {
  HELICONE_GATEWAYS,
  isHeliconeEnabled,
  createHeliconeHeaders,
} from '@/lib/monitoring/helicone';

// Create providers with optional Helicone integration
const heliconeEnabled = isHeliconeEnabled();
const heliconeHeaders = createHeliconeHeaders();

// Anthropic provider (Claude)
const anthropicProvider = createAnthropic({
  ...(heliconeEnabled && {
    baseURL: HELICONE_GATEWAYS.anthropic,
    headers: heliconeHeaders,
  }),
});

// OpenAI provider (GPT, embeddings)
const openaiProvider = createOpenAI({
  ...(heliconeEnabled && {
    baseURL: HELICONE_GATEWAYS.openai,
    headers: heliconeHeaders,
  }),
});

// Google provider (Gemini)
const googleProvider = createGoogleGenerativeAI({
  ...(heliconeEnabled && {
    baseURL: HELICONE_GATEWAYS.google,
    headers: heliconeHeaders,
  }),
});

// Model routing configuration - rozne modele do roznych zadan
// Koszty optymalizowane: drogi model tylko tam gdzie potrzeba jakosci
export const MODEL_CONFIG = {
  // Claude Sonnet 4 - mentoring, long context, empathy, Polish language
  mentor: anthropicProvider('claude-sonnet-4-20250514'),

  // GPT-4.1 - structured curriculum generation, reliable JSON
  curriculum: openaiProvider('gpt-4.1'),

  // Gemini 2.0 Flash - fast, cheap quizzes
  quiz: googleProvider('gemini-2.0-flash'),

  // Embeddings for RAG (Phase 5)
  embedding: openaiProvider('text-embedding-3-small'),
} as const;

// Provider registry with all configured providers
export const registry = createProviderRegistry({
  anthropic: anthropicProvider,
  openai: openaiProvider,
  google: googleProvider,
});

// Helper to get model for specific task
export function getModel(task: keyof typeof MODEL_CONFIG) {
  return MODEL_CONFIG[task];
}

// Get model name string for logging
export function getModelName(task: keyof typeof MODEL_CONFIG): string {
  const model = MODEL_CONFIG[task];
  // Access modelId from the model object
  return (model as { modelId?: string }).modelId || task;
}

// Log Helicone status on init (dev only)
if (process.env.NODE_ENV === 'development') {
  console.log(
    heliconeEnabled
      ? '[AI] Helicone monitoring enabled'
      : '[AI] Helicone monitoring disabled (no HELICONE_API_KEY)'
  );
}
```

Kluczowe zmiany:
1. Importy z `@ai-sdk/*` zmienione na factory functions (createAnthropic, createOpenAI, createGoogleGenerativeAI)
2. Warunkowe dodanie baseURL i headers gdy Helicone jest wlaczony
3. Registry uzywa provider instances zamiast default exports
4. Backward compatible - bez HELICONE_API_KEY dziala jak wczesniej
  </action>
  <verify>
- `npm run build` przechodzi bez bledow
- Bez HELICONE_API_KEY - istniejaca funkcjonalnosc dziala
- Z HELICONE_API_KEY - logi pokazuja "Helicone monitoring enabled"
  </verify>
  <done>AI providers zintegrowane z Helicone - tracking automatyczny</done>
</task>

</tasks>

<verification>
1. `npm run build` przechodzi bez bledow

2. Test bez Helicone (brak HELICONE_API_KEY):
   - Uruchom `npm run dev`
   - Sprawdz logi: "[AI] Helicone monitoring disabled"
   - Wykonaj dowolna akcje AI (np. wygeneruj quiz)
   - Dziala normalnie

3. Test z Helicone (po dodaniu klucza):
   - Dodaj HELICONE_API_KEY do .env.local
   - Restart dev server
   - Sprawdz logi: "[AI] Helicone monitoring enabled"
   - Wykonaj akcje AI
   - Sprawdz https://us.helicone.ai/dashboard - request widoczny
</verification>

<success_criteria>
- [ ] Helicone module utworzony w src/lib/monitoring/
- [ ] Providers zaktualizowane z conditional Helicone config
- [ ] Backward compatible - dziala bez HELICONE_API_KEY
- [ ] Build przechodzi bez bledow
- [ ] Z kluczem - requesty trackowane w Helicone dashboard
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-optimization/07-02-SUMMARY.md`
</output>
