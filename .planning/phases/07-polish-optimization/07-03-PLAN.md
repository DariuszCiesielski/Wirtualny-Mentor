---
phase: 07-polish-optimization
plan: 03
type: execute
wave: 2
depends_on: ["07-02"]
files_modified:
  - src/app/api/cron/refresh-knowledge/route.ts
  - vercel.json
  - src/lib/dal/courses.ts
  - .env.local.example
autonomous: true

must_haves:
  truths:
    - "Cron job wykonuje sie codziennie o 5:00 UTC"
    - "Tylko kursy z dynamicznych domen sa odswiezane (AI, tech, prawo)"
    - "Endpoint jest zabezpieczony CRON_SECRET"
    - "Stare materialy sa wersjonowane (nie usuwane)"
  artifacts:
    - path: "src/app/api/cron/refresh-knowledge/route.ts"
      provides: "Cron endpoint for knowledge refresh"
      exports: ["GET"]
      min_lines: 50
    - path: "vercel.json"
      provides: "Vercel cron configuration"
      contains: "refresh-knowledge"
  key_links:
    - from: "vercel.json"
      to: "src/app/api/cron/refresh-knowledge/route.ts"
      via: "cron schedule"
      pattern: "0 5 \\* \\* \\*"
    - from: "src/app/api/cron/refresh-knowledge/route.ts"
      to: "Supabase"
      via: "admin client"
      pattern: "createAdminClient"
---

<objective>
Utworzyc mechanizm automatycznego odswiezania wiedzy dla dynamicznych dziedzin.

Purpose: Spelnienie wymagania KNOW-03 - baza wiedzy odswiezana dla AI, tech, prawo
Output: Vercel Cron Job odswiezajacy materialy codziennie
</objective>

<execution_context>
@C:\Users\dariu\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dariu\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-polish-optimization/07-RESEARCH.md

# Database context
@src/lib/dal/courses.ts
@src/lib/dal/materials.ts

# Vercel Cron pattern:
# - Define in vercel.json
# - Create API route handler
# - Verify CRON_SECRET header
# - Schedule: "0 5 * * *" = 5:00 AM UTC daily
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dodaj helper do identyfikacji dynamicznych domen</name>
  <files>src/lib/dal/courses.ts</files>
  <action>
Dodaj funkcje do src/lib/dal/courses.ts identyfikujaca kursy wymagajace odswiezania:

```typescript
// Dynamic domains that require frequent knowledge updates
const DYNAMIC_DOMAINS = [
  'ai', 'artificial intelligence', 'sztuczna inteligencja', 'machine learning', 'ml',
  'llm', 'chatgpt', 'claude', 'gpt',
  'tech', 'technologia', 'programming', 'programowanie', 'software', 'javascript',
  'typescript', 'react', 'next.js', 'python', 'rust',
  'prawo', 'law', 'legal', 'ustawa', 'przepisy', 'regulacje',
  'crypto', 'blockchain', 'web3', 'bitcoin', 'ethereum',
  'cybersecurity', 'bezpieczenstwo', 'security',
] as const;

/**
 * Check if course topic is in a dynamic domain requiring frequent updates
 */
export function isDynamicDomain(topic: string): boolean {
  const lowerTopic = topic.toLowerCase();
  return DYNAMIC_DOMAINS.some(domain => lowerTopic.includes(domain));
}

/**
 * Get courses that need knowledge refresh (dynamic domains, not updated in last 24h)
 */
export async function getCoursesNeedingRefresh(): Promise<{
  id: string;
  topic: string;
  userId: string;
}[]> {
  const supabase = await createServerClient();
  const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();

  const { data, error } = await supabase
    .from('courses')
    .select('id, topic, user_id')
    .lt('updated_at', oneDayAgo);

  if (error) throw error;

  // Filter to only dynamic domains
  return (data || [])
    .filter(course => isDynamicDomain(course.topic))
    .map(course => ({
      id: course.id,
      topic: course.topic,
      userId: course.user_id,
    }));
}
```

Funkcje:
1. `isDynamicDomain(topic)` - sprawdza czy temat jest w dynamicznej domenie
2. `getCoursesNeedingRefresh()` - pobiera kursy do odswiezenia (dynamiczne + nieaktualizowane 24h)
  </action>
  <verify>
- Funkcje isDynamicDomain i getCoursesNeedingRefresh eksportowane
- `npm run build` przechodzi
  </verify>
  <done>Helper functions dla knowledge refresh gotowe</done>
</task>

<task type="auto">
  <name>Task 2: Utworz Cron API endpoint</name>
  <files>src/app/api/cron/refresh-knowledge/route.ts, .env.local.example</files>
  <action>
1. Utworz foldery src/app/api/cron/refresh-knowledge/

2. Utworz src/app/api/cron/refresh-knowledge/route.ts:
```typescript
/**
 * Knowledge Refresh Cron Job
 *
 * Triggered daily at 5:00 AM UTC by Vercel Cron.
 * Refreshes materials for courses in dynamic domains (AI, tech, law).
 *
 * Security: Requires CRON_SECRET header from Vercel.
 */

import { NextRequest, NextResponse } from 'next/server';
import { getCoursesNeedingRefresh } from '@/lib/dal/courses';
import { createServerClient } from '@/lib/supabase/server';

// Node.js runtime for database operations
export const runtime = 'nodejs';

// Allow up to 5 minutes for batch processing
export const maxDuration = 300;

export async function GET(request: NextRequest) {
  // Verify Vercel Cron secret
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    console.error('[Cron] Unauthorized request - invalid CRON_SECRET');
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  console.log('[Cron] Knowledge refresh started');

  try {
    // Get courses needing refresh
    const courses = await getCoursesNeedingRefresh();
    console.log(`[Cron] Found ${courses.length} courses to refresh`);

    if (courses.length === 0) {
      return NextResponse.json({
        success: true,
        message: 'No courses need refresh',
        refreshed: 0,
      });
    }

    // For Phase 7 MVP: Just mark courses as needing refresh
    // Full implementation would regenerate materials here
    const supabase = await createServerClient();

    // Update courses to trigger client-side refresh on next visit
    // (Actual regeneration is expensive - we flag and lazy-regenerate)
    const { error } = await supabase
      .from('courses')
      .update({ updated_at: new Date().toISOString() })
      .in('id', courses.map(c => c.id));

    if (error) {
      console.error('[Cron] Error updating courses:', error);
      throw error;
    }

    console.log(`[Cron] Marked ${courses.length} courses for refresh`);

    return NextResponse.json({
      success: true,
      message: `Marked ${courses.length} courses for refresh`,
      refreshed: courses.length,
      courses: courses.map(c => ({ id: c.id, topic: c.topic })),
    });
  } catch (error) {
    console.error('[Cron] Knowledge refresh failed:', error);
    return NextResponse.json(
      { error: 'Refresh failed', details: String(error) },
      { status: 500 }
    );
  }
}
```

3. Zaktualizuj .env.local.example - dodaj:
```
# Vercel Cron Secret (auto-set by Vercel, or generate for local testing)
# Generate: openssl rand -base64 32
CRON_SECRET=
```

Uwagi:
- MVP podejscie: oznaczamy kursy do odswiezenia, faktyczna regeneracja lazy on-demand
- Pelna regeneracja materialow w cron bylaby droga i wolna
- Kursy sa flagowane updated_at -> klient widzi "Odswiezanie dostepne"
  </action>
  <verify>
- Plik src/app/api/cron/refresh-knowledge/route.ts istnieje
- Eksportuje GET handler
- `npm run build` przechodzi
- Curl bez CRON_SECRET zwraca 401
  </verify>
  <done>Cron endpoint zabezpieczony i gotowy</done>
</task>

<task type="auto">
  <name>Task 3: Skonfiguruj Vercel Cron w vercel.json</name>
  <files>vercel.json</files>
  <action>
Utworz lub zaktualizuj vercel.json w root projektu:

```json
{
  "$schema": "https://openapi.vercel.sh/vercel.json",
  "crons": [
    {
      "path": "/api/cron/refresh-knowledge",
      "schedule": "0 5 * * *"
    }
  ]
}
```

Schedule wyjasniony:
- "0 5 * * *" = minute 0, hour 5, every day, every month, every day of week
- = Codziennie o 5:00 AM UTC
- W Polsce: 6:00 rano (zima) lub 7:00 rano (lato)

Uwagi:
- Vercel Hobby: max 1x dziennie, +/-59 min precision
- Vercel Pro: do 1x na minute, precise timing
- CRON_SECRET automatycznie ustawiony przez Vercel przy deploy
  </action>
  <verify>
- vercel.json istnieje w root
- Zawiera cron configuration dla /api/cron/refresh-knowledge
- JSON jest poprawny (walidacja schema)
  </verify>
  <done>Vercel Cron skonfigurowany dla daily refresh</done>
</task>

</tasks>

<verification>
1. `npm run build` przechodzi bez bledow

2. Test lokalny (z CRON_SECRET):
```bash
# Ustaw CRON_SECRET w .env.local
# Uruchom dev server
npm run dev

# Test bez secret - powinno zwrocic 401
curl http://localhost:3000/api/cron/refresh-knowledge

# Test z secret - powinno zwrocic success
curl -H "Authorization: Bearer YOUR_CRON_SECRET" \
  http://localhost:3000/api/cron/refresh-knowledge
```

3. Weryfikacja dynamic domains:
   - Kurs "React i Next.js" -> isDynamicDomain = true
   - Kurs "Gotowanie" -> isDynamicDomain = false

4. Po deploy na Vercel:
   - Vercel Dashboard -> Project -> Cron Jobs -> widoczny job
   - Codziennie o 5:00 UTC -> logi w Vercel Functions
</verification>

<success_criteria>
- [ ] isDynamicDomain helper dziala poprawnie
- [ ] Cron endpoint utworzony i zabezpieczony CRON_SECRET
- [ ] vercel.json z cron configuration
- [ ] Build przechodzi bez bledow
- [ ] Lokalny test z curl dziala
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-optimization/07-03-SUMMARY.md`
</output>
